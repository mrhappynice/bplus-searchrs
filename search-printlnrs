use serde::{Deserialize, Serialize};
use scraper::{Html, Selector};
use axum::{Json, extract::Query};
use futures::future::join_all;
use reqwest::Client;
use std::pin::Pin;
use std::future::Future;
use std::collections::HashSet;

#[derive(Serialize, Clone, Debug)]
pub struct SearchResult {
    pub title: String,
    pub url: String,
    pub content: String,
    pub engine: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ProviderConfig {
    pub id: i64,
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String, // "native", "generic"
    pub api_url: Option<String>,
    pub api_headers: Option<String>,
    pub result_path: Option<String>,
    pub title_path: Option<String>,
    pub url_path: Option<String>,
    pub content_path: Option<String>,
}

pub trait SearchProvider: Send + Sync {
    fn search(&self, client: Client, query: String, timeframe: Option<String>) -> Pin<Box<dyn Future<Output = Vec<SearchResult>> + Send>>;
}

// 1. Generic API Provider
struct GenericApiProvider {
    config: ProviderConfig,
}

impl GenericApiProvider {
    fn extract(&self, val: &serde_json::Value, path: Option<&String>) -> String {
        let path = match path { Some(p) if !p.is_empty() => p, _ => return "".to_string() };
        let parts: Vec<&str> = path.split('.').collect();
        let mut curr = val;
        for part in parts {
            if let Some(idx) = part.parse::<usize>().ok() {
                if let Some(arr) = curr.as_array() { 
                    if idx < arr.len() { curr = &arr[idx]; } else { return "".to_string(); }
                } else { return "".to_string(); }
            } else {
                curr = &curr[part];
            }
        }
        curr.as_str().unwrap_or("").to_string()
    }
}

impl SearchProvider for GenericApiProvider {
    fn search(&self, client: Client, query: String, _timeframe: Option<String>) -> Pin<Box<dyn Future<Output = Vec<SearchResult>> + Send>> {
        let config = self.config.clone();
        Box::pin(async move {
            let url_tmpl = config.api_url.as_deref().unwrap_or("");
            if url_tmpl.is_empty() { return vec![]; }
            let url = url_tmpl.replace("{q}", &urlencoding::encode(&query));
            
            println!("Debug: Fetching Generic API: {}", url); // DEBUG LOG

            let mut req = client.get(&url);
            if let Some(h_str) = &config.api_headers {
                if let Ok(headers) = serde_json::from_str::<std::collections::HashMap<String, String>>(h_str) {
                    for (k, v) in headers { req = req.header(&k, &v); }
                }
            }

            let mut results = Vec::new();
            match req.send().await {
                Ok(resp) => {
                    if let Ok(json) = resp.json::<serde_json::Value>().await {
                        let mut root = &json;
                        // Navigate to results array
                        if let Some(rpath) = &config.result_path {
                            for part in rpath.split('.') {
                                if !part.is_empty() { root = &root[part]; }
                            }
                        }
                        
                        if let Some(arr) = root.as_array() {
                            println!("Debug: Found {} items in API response", arr.len()); // DEBUG LOG
                            for item in arr {
                                let title = GenericApiProvider{config: config.clone()}.extract(item, config.title_path.as_ref());
                                let url = GenericApiProvider{config: config.clone()}.extract(item, config.url_path.as_ref());
                                
                                // Only add if we found a URL
                                if !url.is_empty() {
                                    results.push(SearchResult {
                                        title: if title.is_empty() { "No Title".into() } else { title },
                                        url,
                                        content: GenericApiProvider{config: config.clone()}.extract(item, config.content_path.as_ref()),
                                        engine: config.name.clone()
                                    });
                                } else {
                                    println!("Debug: Skipped item, no URL found via path: {:?}", config.url_path);
                                }
                            }
                        } else {
                            println!("Debug: Could not find array at path: {:?}", config.result_path);
                        }
                    } else {
                        println!("Debug: Failed to parse JSON");
                    }
                },
                Err(e) => println!("Debug: Request failed: {}", e),
            }
            results
        })
    }
}

// 2. Native Provider Wrapper
struct NativeProvider {
    id: String, 
    _name: String,
}

impl SearchProvider for NativeProvider {
    fn search(&self, client: Client, query: String, timeframe: Option<String>) -> Pin<Box<dyn Future<Output = Vec<SearchResult>> + Send>> {
        let id = self.id.clone();
        Box::pin(async move {
            match id.as_str() {
                "native_ddg" => ddg_web(client, query, timeframe).await,
                "native_mojeek" => mojeek_web(client, query).await,
                "native_wiki" => wikipedia_web(client, query).await,
                "native_reddit" => reddit_web(client, query).await,
                "native_stack" => stackexchange_web(client, query).await,
                "native_searxng" => searxng_search(client, query, timeframe).await,
                _ => vec![]
            }
        })
    }
}

pub async fn perform_search(
    client: Client, 
    providers: Vec<ProviderConfig>, 
    query: String,
    timeframe: Option<String>
) -> Vec<SearchResult> {
    let mut futures = Vec::new();
    println!("Debug: Starting search with {} providers", providers.len());

    for p in providers {
        let provider: Box<dyn SearchProvider> = if p.type_ == "generic" {
            Box::new(GenericApiProvider { config: p })
        } else {
            Box::new(NativeProvider { 
                id: p.api_url.clone().unwrap_or_default(), 
                _name: p.name.clone() 
            })
        };
        futures.push(provider.search(client.clone(), query.clone(), timeframe.clone()));
    }

    let results_list = join_all(futures).await;
    let mut all = Vec::new();
    for res in results_list { all.extend(res); }

    // Dedup
    let mut seen = HashSet::new();
    let mut unique = Vec::new();
    for r in all {
        if !seen.contains(&r.url) {
            seen.insert(r.url.clone());
            unique.push(r);
        }
    }
    
    // Sort
    let q_low = query.to_lowercase();
    unique.sort_by(|a, b| {
        let ascore = if a.title.to_lowercase().contains(&q_low) { 1 } else { 0 };
        let bscore = if b.title.to_lowercase().contains(&q_low) { 1 } else { 0 };
        bscore.cmp(&ascore)
    });
    
    println!("Debug: Total unique results found: {}", unique.len());
    unique
}

// --- Native Impls ---
async fn searxng_search(client: Client, query: String, timeframe: Option<String>) -> Vec<SearchResult> {
    let base = std::env::var("SEARXNG_URL").unwrap_or_default();
    if base.is_empty() { return vec![]; }
    let mut url = format!("{}/search?q={}&format=json", base, urlencoding::encode(&query));
    if let Some(tf) = timeframe {
        if ["day", "week", "month"].contains(&tf.as_str()) { url.push_str(&format!("&time_range={}", tf)); }
    }
    if let Ok(resp) = client.get(&url).send().await {
        if let Ok(json) = resp.json::<serde_json::Value>().await {
             if let Some(arr) = json["results"].as_array() {
                 return arr.iter().map(|r| SearchResult{
                     title: r["title"].as_str().unwrap_or("").into(),
                     url: r["url"].as_str().unwrap_or("").into(),
                     content: r["content"].as_str().unwrap_or("").into(),
                     engine: "SearXNG".into()
                 }).collect();
             }
        }
    }
    vec![]
}

async fn ddg_web(client: Client, q: String, timeframe: Option<String>) -> Vec<SearchResult> {
    let mut url = format!("https://duckduckgo.com/html/?q={}&kp=1", urlencoding::encode(&q));
    if let Some(tf) = timeframe {
        let df = match tf.as_str() { "day" => "d", "week" => "w", "month" => "m", _ => "" };
        if !df.is_empty() { url.push_str(&format!("&df={}", df)); }
    }
    if let Ok(resp) = client.get(&url).send().await {
        let html = resp.text().await.unwrap_or_default();
        let doc = Html::parse_document(&html);
        let res_sel = Selector::parse(".result").unwrap();
        let a_sel = Selector::parse("a.result__a").unwrap();
        let s_sel = Selector::parse(".result__snippet").unwrap();
        let mut out = Vec::new();
        for el in doc.select(&res_sel) {
            if let Some(a) = el.select(&a_sel).next() {
                out.push(SearchResult {
                    title: a.text().collect::<String>().trim().into(),
                    url: a.value().attr("href").unwrap_or("").into(),
                    content: el.select(&s_sel).next().map(|s| s.text().collect::<String>()).unwrap_or_default().trim().into(),
                    engine: "DuckDuckGo".into()
                });
            }
        }
        out
    } else { vec![] }
}

async fn mojeek_web(client: Client, q: String) -> Vec<SearchResult> {
    let url = format!("https://www.mojeek.com/search?q={}", urlencoding::encode(&q));
    if let Ok(resp) = client.get(&url).send().await {
        let html = resp.text().await.unwrap_or_default();
        let doc = Html::parse_document(&html);
        let sel = Selector::parse("div.results div.result").unwrap();
        let mut out = Vec::new();
        for el in doc.select(&sel) {
            if let Some(a) = el.select(&Selector::parse("a").unwrap()).next() {
                out.push(SearchResult {
                    title: a.text().collect::<String>().trim().into(),
                    url: a.value().attr("href").unwrap_or("").into(),
                    content: el.select(&Selector::parse("p.s").unwrap()).next().map(|s| s.text().collect::<String>()).unwrap_or_default(),
                    engine: "Mojeek".into()
                });
            }
        }
        out
    } else { vec![] }
}

async fn wikipedia_web(client: Client, q: String) -> Vec<SearchResult> {
    let url = format!("https://en.wikipedia.org/w/api.php?action=query&list=search&utf8=1&format=json&srsearch={}", urlencoding::encode(&q));
    if let Ok(resp) = client.get(&url).send().await {
        if let Ok(json) = resp.json::<serde_json::Value>().await {
            if let Some(arr) = json["query"]["search"].as_array() {
                return arr.iter().map(|i| SearchResult{
                    title: i["title"].as_str().unwrap_or("").into(),
                    url: format!("https://en.wikipedia.org/wiki/{}", i["title"].as_str().unwrap_or("").replace(" ","_")),
                    content: i["snippet"].as_str().unwrap_or("").replace("<span class=\"searchmatch\">","").replace("</span>",""),
                    engine: "Wikipedia".into()
                }).collect();
            }
        }
    }
    vec![]
}

async fn reddit_web(client: Client, q: String) -> Vec<SearchResult> {
    let url = format!("https://www.reddit.com/search.json?q={}&sort=relevance&limit=10", urlencoding::encode(&q));
    if let Ok(resp) = client.get(&url).send().await {
        if let Ok(json) = resp.json::<serde_json::Value>().await {
            if let Some(arr) = json["data"]["children"].as_array() {
                return arr.iter().map(|c| SearchResult{
                    title: c["data"]["title"].as_str().unwrap_or("").into(),
                    url: format!("https://www.reddit.com{}", c["data"]["permalink"].as_str().unwrap_or("")),
                    content: c["data"]["selftext"].as_str().unwrap_or("").chars().take(200).collect(),
                    engine: "Reddit".into()
                }).collect();
            }
        }
    }
    vec![]
}

async fn stackexchange_web(client: Client, q: String) -> Vec<SearchResult> {
    let url = format!("https://api.stackexchange.com/2.3/search/advanced?order=desc&sort=relevance&q={}&site=stackoverflow", urlencoding::encode(&q));
    if let Ok(resp) = client.get(&url).send().await {
        if let Ok(json) = resp.json::<serde_json::Value>().await {
            if let Some(arr) = json["items"].as_array() {
                return arr.iter().map(|i| SearchResult{
                    title: i["title"].as_str().unwrap_or("").into(),
                    url: i["link"].as_str().unwrap_or("").into(),
                    content: format!("Score: {}", i["score"]),
                    engine: "StackOverflow".into()
                }).collect();
            }
        }
    }
    vec![]
}

pub async fn suggest(Query(p): Query<std::collections::HashMap<String,String>>) -> Json<Vec<String>> {
    let q = p.get("q").cloned().unwrap_or_default();
    if q.is_empty() { return Json(vec![]); }
    let url = format!("https://duckduckgo.com/ac/?type=list&q={}", q);
    let client = Client::new();
    if let Ok(resp) = client.get(&url).send().await {
         if let Ok(json) = resp.json::<serde_json::Value>().await {
             if let Some(arr) = json[1].as_array() {
                 return Json(arr.iter().filter_map(|v| v.as_str().map(String::from)).collect());
             }
         }
    }
    Json(vec![])
}